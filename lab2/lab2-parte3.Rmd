---
title: "Lab2 - Regressão Linear"
autor: "Arthur Lustosa"
output: 
  html_document:
    toc : true
    toc_float: true
    
---

```{r setup, include=FALSE}
library(dplyr)
library(reshape2)
library(GGally)
library(ggplot2)
library(corrplot)
library(caret)
```


## Lendo os dados

```{r}
graduados.train <- read.csv("dados/graduados_treino.csv")
graduados.test <- read.csv("dados/graduados_teste.csv")
```

```{r}
colnames(graduados.train) <- c("matricula", "ano_evasao", "periodo_evasao", "cod_disciplina", "disciplina", "creditos", "media")
colnames(graduados.test) <- c("matricula", "ano_evasao", "periodo_evasao", "cod_disciplina", "disciplina", "creditos", "media")
```

## Conhecendo os dados
Os dados usados são referentes ao histórico de alunos do curso de computação da UFCG. A tarefa é, utilizando regressão linear, explicar o desempenho acadêmico.

O dataset inicial possui 15751 observações com 7 variáveis. No processo de leitura algumas alterações tiveram de ser feitas, encontramos muitos NaNs e tivemos que removelos para não influenciar nas análises que serão feitas. Depois calculamos os CRAs (Coeficiente de Rendimento Acadêmico) dos alunos. 
```{r warning=F, message=F}

# DADOS TREINO

#ordenando os dados pela matrícula
graduados.train <- graduados.train %>%
  arrange(matricula)

#filtrando dados e removendo os NaNs
graduados.clean <- graduados.train %>%
  filter(!is.na(media))

#calculando CRA dos alunos e salvando numa coluna
graduados.cra <- graduados.clean %>%
  group_by(matricula) %>%
  mutate(cra.contrb = media*creditos) %>%
  summarise(cra = sum(cra.contrb)/sum(creditos))

#utilizando a função dcast para deixar o dataset na forma ideal para a análise
graduados.model.input <- graduados.clean %>%
  group_by(matricula, disciplina) %>%
  filter(media == max(media))%>%
  ungroup() %>%
  select(matricula, disciplina, media) %>%
  mutate(disciplina = as.factor(gsub(" ", ".", disciplina))) %>%
  dcast(matricula ~disciplina, mean) %>%
  merge(graduados.cra)

#selecionando cra e disciplinas do primeiro e segundo período
p1.p2.train <- graduados.model.input %>%
  select(Laboratório.de.Programação.I, Programação.I, Introdução.à.Computação, Cálculo.Diferencial.e.Integral.I, Álgebra.Vetorial.e.Geometria.Analítica, Leitura.e.Produção.de.Textos, Cálculo.Diferencial.e.Integral.II, Matemática.Discreta, Programação.II, Teoria.dos.Grafos, Fundamentos.de.Física.Clássica, Laboratório.de.Programação.II, cra)

#renomeando colunas
colnames(p1.p2.train) <- c("C1", "Vetorial", "LPT", "P1", "IC", "LP1","C2", "Discreta", "P2", "Grafos", "Física", "LP2", "CRA")



# DADOS TESTE

#ordenando os dados pela matrícula
graduados.test <- graduados.test %>%
  arrange(matricula)

#filtrando dados e removendo os NaNs
graduados.clean <- graduados.test %>%
  filter(!is.na(media))

#calculando CRA dos alunos e salvando numa coluna
graduados.cra <- graduados.clean %>%
  group_by(matricula) %>%
  mutate(cra.contrb = media*creditos) %>%
  summarise(cra = sum(cra.contrb)/sum(creditos))

#utilizando a função dcast para deixar o dataset na forma ideal para a análise
graduados.model.input <- graduados.clean %>%
  group_by(matricula, disciplina) %>%
  filter(media == max(media))%>%
  ungroup() %>%
  select(matricula, disciplina, media) %>%
  mutate(disciplina = as.factor(gsub(" ", ".", disciplina))) %>%
  dcast(matricula ~disciplina, mean) %>%
  merge(graduados.cra)

#selecionando cra e disciplinas do primeiro e segundo período
p1.p2.test <- graduados.model.input %>%
  select(Laboratório.de.Programação.I, Programação.I, Introdução.à.Computação, Cálculo.Diferencial.e.Integral.I, Álgebra.Vetorial.e.Geometria.Analítica, Leitura.e.Produção.de.Textos, Cálculo.Diferencial.e.Integral.II, Matemática.Discreta, Programação.II, Teoria.dos.Grafos, Fundamentos.de.Física.Clássica, Laboratório.de.Programação.II, cra)

#renomeando colunas
colnames(p1.p2.test) <- c("C1", "Vetorial", "LPT", "P1", "IC", "LP1","C2", "Discreta", "P2", "Grafos", "Física", "LP2", "CRA")



#substituindo NaN pelo CRA
for (i in 1:nrow(p1.p2.train)){
  for (j in 1:ncol(p1.p2.train)){
    if(is.na(p1.p2.train[i,j])){
      p1.p2.train[i,j] = p1.p2.train$CRA[i]

    }
    if(is.na(p1.p2.test[i,j])){
      p1.p2.test[i, j] = p1.p2.test$CRA[i]
    }
  }
}

```



O que fazer:
1. Separe os dados em treino e teste (por exemplo 90% para treino 10% para teste).
2. Usando todas as variáveis disponíveis (disciplinas do primeiro e segundo período), use validação cruzada (nos dados de treino) para tunar um modelo de regressão Ridge.
3. Mesmo que item acima mas usando um modelo de regressão Lasso.
4. Compare os dois modelos nos dados de teste em termos de RMSE.
5. Quais as variáveis mais importantes segundo o modelo de regressão Lasso? Alguma variável foi descartada? Quais?
6. Re-treine o melhor modelo (dessa vez nos dados de treino sem validação cruzada) e reporte o RMSE no teste.
7. Use o modelo treinado em 6 e aplique nos dados de teste que vamos disponibilizar.
8. Crie novos atributos a partir dos existentes para tentar melhorar o seu modelo.


Usamos a biblioteca caret para particionar os dados e montarmos nosso conjunto de teste.




Criando modelo de regressão do tipo Ridge que utiliza todas as variáveis.




```{r}
#Modelo Ridge
set.seed(825)

ctrl <- trainControl(method = "repeatedcv", repeats = 5, number = 10)
lambda.grid <- expand.grid(lambda = 10^seq(10, -2, length=100))

model.rigde.p1.p2 <- train(CRA ~ . ,
                                 data = p1.p2.train,
                                 method = "ridge",
                                 tuneGrid = lambda.grid,
                                 trControl = ctrl,
                                 metric = 'RMSE',
                                 preProcess=c('scale', 'center'))

model.rigde.p1.p2

```

Criando modelo de regressão do tipo Lasso que utiliza todas as variáveis.

```{r}
#Modelo Lasso
model.lasso.p1.p2 <- train(CRA ~ . ,
                                 data = p1.p2.train,
                                 method = "lasso",
                                 tuneLength = 10,
                                 metric = 'RMSE',
                                 preProcess=c('scale', 'center'))

model.lasso.p1.p2 

#importancia das variaveis
roc_imp2 <- varImp(model.lasso.p1.p2, scale=F)
plot(roc_imp2)

```





