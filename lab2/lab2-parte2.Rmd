---
title: "Lab2 - Regressão Linear"
output: 
  html_document:
    toc : true
    toc_float: true
    
---

```{r setup, include=FALSE}
library(dplyr)
library(reshape2)
library(GGally)
library(ggplot2)
library(corrplot)
```


## Lendo os dados

```{r}
dados <- read.csv("dados/graduados.csv")
```

## Conhecendo os dados
Os dados usados são referentes ao histórico de alunos do curso de computação da UFCG. A tarefa é, utilizando regressão linear, explicar o desempenho acadêmico.

O dataset inicial possui 15751 observações com 7 variáveis. No processo de leitura algumas alterações tiveram de ser feitas, encontramos muitos NaNs e tivemos que removelos para não influenciar nas análises que serão feitas. Depois calculamos os CRAs (Coeficiente de Rendimento Acadêmico) dos alunos. 
```{r}
#ordenando os dados pela matrícula
graduados <- dados %>%
  arrange(matricula)

#filtrando dados e removendo os NaNs
graduados.clean <- graduados %>%
  filter(!is.na(media))

#calculando CRA dos alunos e salvando numa coluna
graduados.cra <- graduados.clean %>%
  group_by(matricula) %>%
  mutate(cra.contrb = media*creditos) %>%
  summarise(cra = sum(cra.contrb)/sum(creditos))

#utilizando a função dcast para deixar o dataset na forma ideal para a análise
graduados.model.input <- graduados.clean %>%
  group_by(matricula, disciplina) %>%
  filter(media == max(media))%>%
  ungroup() %>%
  select(matricula, disciplina, media) %>%
  mutate(disciplina = as.factor(gsub(" ", ".", disciplina))) %>%
  dcast(matricula ~disciplina, mean) %>%
  merge(graduados.cra)
```

A ideia principal dessa análise é explicar o desempenho acadêmico final dos alunos de computação, analisando como foi o seu desempenho no início do curso. Para isso vamos analisar seus rendimentos no primeiro e no segundo período do curso, levando em consideração suas notas nas disciplinas cursadas e, usando regressão linear, tentar explicar seu desempenho final. Nossa análise será dividida por partes, primeiro vamos nos aprofundar no primeiro período, ver quais disciplinas mais afetam o desempenho do aluno, depois vamos ver quais disciplinas não influenciam, nesse caso vamos identificar as cadeiras que não tem valor em significância para o modelo que queremos construi e assim removê-las. Depois de selecionar as variáveis mais importantes vamos montar nosso modelo.

##1 

```{r fig.width=12, fig.height=10}

#selecionando disciplinas do primeiro e segundo período e cra
p1.p2 <- graduados.model.input %>%
  select(Laboratório.de.Programação.I, Programação.I, Introdução.à.Computação, Cálculo.Diferencial.e.Integral.I, Álgebra.Vetorial.e.Geometria.Analítica, Leitura.e.Produção.de.Textos, Cálculo.Diferencial.e.Integral.II, Matemática.Discreta, Programação.II, Teoria.dos.Grafos, Fundamentos.de.Física.Clássica, Laboratório.de.Programação.II, cra)

p1.p2 <- na.omit(p1.p2)

lm.p1p2 <-lm(cra ~ ., p1.p2)

summary(lm.p1p2)
```
Temos agora nosso primeiro modelo com todas as variáveis (disciplinas) do primeiro e do segundo período. Esse modelo consegue explicar ~68% da variável alvo CRA. Para melhorar nosso modelo vamos analisar a correlação entre as variáveis.

```{r fig.width=12, fig.height=10}
#calculando matriz de correlação
correlationMatrix <- cor(p1.p2)

#utlizamos a bibliota corrplot para montar o gráfico com as correlações
corrplot(correlationMatrix, method="circle", type="lower", order="hclust", addCoef.col = "black")
```

Analisando a matriz de correlação das variáveis observamos que a maioria das variaveis possue uma correlaçao ate 0.5 ou inferior, baseado nisso assumimos um treshhold de 0.65, ou seja, acima desse valor a correlaçao entre as variaveis e considerada alta. 
Para melhorar nosso modelo escolhemos uma estrategia de remover as variaveis que possuem uma correlacao alta e um p-valor alto.

```{r}
lm.p1p2.melhorado <-lm(cra ~ . -Laboratório.de.Programação.I, p1.p2, -Teoria.dos.Grafos, Programação.II)

summary(lm.p1p2.melhorado)

#reduzindo gráficos residos 
#par(mfrow=c(2,1))
#plot(lm.p1p2.melhor, which=1:2)

```

As variaveis retiradas foram LPI, Grafos e Programaçao 2. Observando nosso modelo melhorado, observamos que o R2 ajustado reduziu.

##1 - Primeiro Periodo
Vamos filtrar nosso dataset original para utilizarmos apenas as disciplinas referentes ao primeiro período.
```{r fig.width=12, fig.height=10}
#filtrando disciplinas
primeiro.periodo <- graduados.model.input %>%
  select(matricula, Cálculo.Diferencial.e.Integral.I, Álgebra.Vetorial.e.Geometria.Analítica, Leitura.e.Produção.de.Textos, Programação.I, Introdução.à.Computação, Laboratório.de.Programação.I, cra)

#removendo NaNs
primeiro.periodo <- na.omit(primeiro.periodo)
primeiro.periodo <- primeiro.periodo %>% select(-matricula)

#plotando relacionamento entra as disciplinas
ggpairs(primeiro.periodo)

#utilizamos a função melt para transformar os dados e podermos ter o plot dos histogramas de todas as disciplinas
df1 <- melt(primeiro.periodo)

#plotando histogramas
ggplot(df1,aes(x = value)) + 
    facet_wrap(~variable, scales = "free_x") + 
    geom_histogram(aes(fill=..count..))
```

###1.1 - Relacionamento entre variáveis.
Nos gráficos acima podemos ver o relacionamento entre as variáveis. Podemos ver a curva de suas respectivas distribuições, com isso podemos dizer que a maioria se comporta como uma distribuição normal, isso significa que os dados estão bem distribuído e vemos também que não temos algum inviesamento que deve ser levado em consideração. Chegamos a conlusão que não será necessário aplicar alguma transformação nas variáveis. Podemos seguir adiante com nossa análise.


###1.2 - Analisando Matriz de correlação
```{r fig.width=12, fig.height=10}
#calculando matriz de correlação
correlationMatrix1 <- cor(primeiro.periodo)

#utlizamos a bibliota corrplot para montar o gráfico com as correlações
corrplot(correlationMatrix1, method="circle", type="lower", order="hclust", addCoef.col = "black")
```

Observe este gráfico atentamente. Variáveis bem correlacionadas com a variável resposta (CRA) produzirão modelos com resultados mais expressivos. Vemos que todas as nossas váriáveis possuem um correlação significativa com a variável resposta. A disciplina de Introdução a Computação é a que possue a maior correlação, por isso vamos explorar essa correlação mais a fundo montando um modelo de regressão linear apenas com essa variável.


####1.2.1 - Regressão Linear com a váriável mais correlacionada
Observando a matriz de correlação, percebemos que a variável que possue correlação mais alta com o CRA é a disciplina de Introdução a computação, para entendermos mais essa correlação vamos gerar um modelo de regressão linear apenas para essa variável e observar os resultados. 

```{r}
#modelo de regressao linear apenas com a disciplina de (IC) Introdução a Computação
IC <- primeiro.periodo$Introdução.à.Computação
CRA.p.1 <- primeiro.periodo$cra

lm.IC = lm(CRA.p.1 ~ IC)
```
Vamos analisar nosso modelo
```{r}
summary(lm.IC)
```
Vamos calcular as predições e analisar os resíduos do nosso modelo
```{r}
predicoes = predict.lm(lm.IC,primeiro.periodo)
residuos = CRA.p.1 - predicoes
```
####1.2.2 - Gráficos de diagnósticos
```{r fig.width=12, fig.height=10}
axisRange = extendrange(c(CRA.p.1,predicoes)) #deixando as variáveis na mesma escala

#plot modelo
plot(CRA.p.1,predicoes, xlab="CRA", ylab="Introdução à Computação")
abline(0,1,col="red",lty=2,lwd=2)

```

####1.2.3 - Gráficos de diagnósticos referentes aos resíduos.
Plotando previsões versus resíduos
```{r fig.width=12, fig.height=10}
#plot residuos
plot(predicoes,residuos)
abline(h=0,col="blue",lty=2,lwd=2)

```
Verificando se os resíduos seguem uma distribuição normal com média 0:
```{r fig.width=12, fig.height=10}
qqnorm(residuos)
qqline(residuos, col = 2,lwd=2,lty=2)
```
Verificando frequência dos resíduos
```{r fig.width=12, fig.height=10}
ggplot(lm.IC, aes(.resid)) + labs(title="Frequência de resíduos", x= "Resíduo", y="Frequência") + 
  geom_freqpoly(binwidth = 0.5) 
```
Analisando os três gráficos mostrados acima, conseguimos ver que os resíduos possuem uma distribuição simétrica em relação a linha tracejada, não temos nenhum padrão que possa ser considerado o que significa que nosso modelo está bem elaborado.  No segundo gráfico, temos que os resíduos seguem uma distribuição normal com média zero, a sobreposição dos pontos sobre a linha vermelha nos mostra isso. No terceiro gŕafico observamos a a frequência dos nossos resíduos e vemos que ela tem um coportamento bem similiar a de uma normal.

Após analisar a relação entre a disciplina de Introdução a Computação e seu reflexo no CRA do aluno, vamos construir um modelo que leva em consideração todas as disciplinas do primeiro período 

###1.3 - Modelo
Agora vamos para o nosso modelo principal da análise do primeiro período. Nele estamos utilizando todas as nossas variáveis.
```{r}
#modelo utilizando todas as variaveis
lm.primeiro.periodo <- lm(cra ~ Laboratório.de.Programação.I + Programação.I + Introdução.à.Computação + Cálculo.Diferencial.e.Integral.I + Álgebra.Vetorial.e.Geometria.Analítica + Leitura.e.Produção.de.Textos, primeiro.periodo)

summary(lm.primeiro.periodo)

```
Analisando nosso modelo, vemos que as variáveis 

####1.3.1 - Gráficos de Diagnóstico

```{r fig.width=12, fig.height=10}
#plot do modelo
prediction <- predict(lm.primeiro.periodo)

lm_prediction <- data.frame(pred = prediction, obs = primeiro.periodo$cra)

ggplot(lm_prediction, aes(pred, obs)) +  geom_point(alpha = 0.1, position = position_jitter(width = 0.3)) + 
  labs(title="Previsão do modelo", x= "Predição", y="CRA") +  
  geom_line(aes(y = predict(lm.primeiro.periodo, primeiro.periodo)), colour = "red")
```

####1.3.2 - Gráficos de diagnósticos referentes aos resíduos
Plotando previsões versus resíduos
```{r fig.width=12, fig.height=10}
predicoes = predict.lm(lm.primeiro.periodo,primeiro.periodo)
residuos = primeiro.periodo$cra - predicoes
plot(predicoes,residuos)
abline(h=0,col="blue",lty=2,lwd=2)

```
Verificando se os resíduos seguem uma distribuição normal com média 0:
```{r fig.width=12, fig.height=10}
qqnorm(residuos)
qqline(residuos, col = 2,lwd=2,lty=2)
```
Verificando frequência dos resíduos
```{r fig.width=12, fig.height=10}
ggplot(lm.primeiro.periodo, aes(.resid)) + labs(title="Frequência de resíduos", x= "Resíduo", y="Frequência") + 
  geom_freqpoly(binwidth = 0.5) 
```



##2 - Segundo Periodo
```{r}
segundo.periodo <-  graduados.model.input %>%
  select(matricula, Cálculo.Diferencial.e.Integral.II, Matemática.Discreta, Programação.II, Teoria.dos.Grafos, Fundamentos.de.Física.Clássica, Laboratório.de.Programação.II, cra)

segundo.periodo <- na.omit(segundo.periodo)
segundo.periodo <- segundo.periodo %>% select(-matricula)

ggpairs(segundo.periodo)

df2 <- melt(segundo.periodo)

ggplot(df2,aes(x = value)) + 
    facet_wrap(~variable, scales = "free_x") + 
    geom_histogram()

```

###2.1 - Relacionamento entre variáveis.

###2.2 - Analisando Matriz de correlação
```{r}
correlationMatrix2 <- cor(segundo.periodo)
print(correlationMatrix2)
corrplot(correlationMatrix2, method="circle", type="lower", order="hclust", addCoef.col = "black")
```

####2.2.1 - Regressão Linear com a váriável mais correlacionada

####2.2.2 - Gráficos de diagnósticos

####2.2.3 - Gráficos de diagnósticos referentes aos resíduos

###2.3 - Modelo
```{r}
lm.segundo.periodo <- lm(cra ~ Cálculo.Diferencial.e.Integral.II + Matemática.Discreta + Programação.II + Teoria.dos.Grafos+ Fundamentos.de.Física.Clássica+ Laboratório.de.Programação.II, segundo.periodo)

summary(lm.segundo.periodo)


#plot do modelo
prediction <- predict(lm.segundo.periodo)

exp.prediction <- exp(prediction) - 1 #transformando o vetor de predição para a unidade original do problema (em ha).

lm_prediction <- data.frame(pred = exp.prediction, obs = segundo.periodo$cra)


ggplot(lm_prediction, aes(pred, obs)) +  geom_point(alpha = 0.1, position = position_jitter(width = 0.3)) + 
  labs(title="Previsão do modelo", x= "Predição", y="CRA") +  
  geom_line(aes(y = predict(lm.segundo.periodo, segundo.periodo)), colour = "red")
```

####2.3.1 - Gráficos de Diagnóstico
Plotando previsões versus resíduos
```{r}
predicoes = predict.lm(lm.segundo.periodo,segundo.periodo)
residuos = segundo.periodo$cra - predicoes
plot(predicoes,residuos)
abline(h=0,col="blue",lty=2,lwd=2)

```

####2.3.2 - Gráficos de diagnósticos referentes aos resíduos
Verificando se os resíduos seguem uma distribuição normal com média 0:
```{r}
qqnorm(residuos)
qqline(residuos, col = 2,lwd=2,lty=2)
```
Verificando frequência dos resíduos
```{r}
ggplot(lm.segundo.periodo, aes(.resid)) + labs(title="Frequência de resíduos", x= "Resíduo", y="Frequência") + 
  geom_freqpoly(binwidth = 0.5) 
```

##3 - Prevendo próprio desempenho

##4 - Conclusões Finais
